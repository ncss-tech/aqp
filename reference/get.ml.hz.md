# Determine ML Horizon Boundaries

This function accepts input from
[`slab()`](https://ncss-tech.github.io/aqp/reference/slab.md) (a
`data.frame`) along with a vector of horizon names, and returns a
`data.frame` of the most likely horizon boundaries.

This function expects that `x` is a `data.frame` generated by
[`slab()`](https://ncss-tech.github.io/aqp/reference/slab.md). If `x`
was not generated by
[`slab()`](https://ncss-tech.github.io/aqp/reference/slab.md), then
`o.names` is required.

## Usage

``` r
get.ml.hz(x, o.names = attr(x, which = "original.levels"))
```

## Arguments

- x:

  `data.frame`, output from
  [`slab()`](https://ncss-tech.github.io/aqp/reference/slab.md)

- o.names:

  an optional character vector of horizon designations that will be used
  in the final table

## Value

A `data.frame` with the following columns:

- `hz`: horizon names

- `top`: horizon top depth

- `bottom`: horizon bottom depth

- `confidence`: integrated probability over thickness of each ML
  horizon, rounded to the nearest integer

- `pseudo.brier`: A "pseudo"" Brier Score for a multi-class prediction,
  where the most-likely horizon label is treated as the "correct"
  outcome. Details on the calculation for traditional Brier Scores here:
  <https://en.wikipedia.org/wiki/Brier_score>. Lower values suggest
  better agreement between ML horizon label and class-wise
  probabilities.

- `mean.H`: mean Shannon entropy (bits), derived from probabilities
  within each most-likely horizon. Larger values suggest more confusion
  within each ML.

## References

Beaudette, D. E., Roudier, P., & Skovlin, J. (2016). Probabilistic
representation of genetic soil horizons. Digital soil morphometrics,
281-293.

## See also

[`slab()`](https://ncss-tech.github.io/aqp/reference/slab.md)

## Author

D.E. Beaudette

## Examples

``` r
# init SPC
data(sp1)
depths(sp1) <- id ~ top + bottom

# set horizon designation metadata
hzdesgnname(sp1) <- 'name'

# generalize horizon designations from character vector
# result is an ordered factor
sp1$genhz <- generalizeHz(
  sp1$name,
  new = c('O','A','B','C'),
  pat = c('O', '^A','^B','C'),
  ordered = TRUE
)

# compute slice-wise GHL probability
# so that it sums to contributing fraction
# from 0-150cm
a <- slab(sp1, fm = ~ genhz, cpm = 1, slab.structure = 0:150)
#> horizons with zero thickness have been omitted from results

# note original GHL names are set by slab()
attr(a, 'original.levels')
#> [1] "O"        "A"        "B"        "C"        "not-used"

# generate table of ML horizonation
get.ml.hz(a)
#>   hz top bottom confidence pseudo.brier    mean.H
#> 1  O   0      2         37    0.3950617 0.9910761
#> 2  A   2     32         75    0.1547325 0.7922828
#> 3  B  32    145         57    0.3574667 1.0813045
#> 4  C 145    150         71    0.1250000 0.8112781
```
